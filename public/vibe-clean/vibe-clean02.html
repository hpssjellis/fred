<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Gem</title>
</head>
<body style="font-family: 'Inter', sans-serif; background-color: #1a202c; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; color: white; padding: 1rem;">
    <h1 style="font-size: 1.875rem; font-weight: bold; margin-bottom: 1rem;">Flappy Gem</h1>
    <canvas id="gameCanvas" style="border-radius: 0.75rem; background-color: #4a5568; border: 2px solid #a0aec0; width: 100%; height: auto;" width="320" height="480"></canvas>
    <br>
    <span class="score-display" style="margin-top: 1rem; font-size: 1.25rem;">
        Score: <span id="score">0</span>
    </span>
    <br><br>

    <!-- Message Box -->
    <span id="message-box" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #2c5282; padding: 2rem; border-radius: 1rem; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); text-align: center; z-index: 10;">
        <h2 id="message-title" style="font-size: 1.5rem; font-weight: bold; margin-bottom: 0.5rem;">Game Over</h2>
        <br>
        <span id="message-text" style="font-size: 1.125rem; margin-bottom: 1rem;">You crashed! Click below to try again.</span>
        <br><br>
        <button id="restartButton" style="padding: 0.5rem 1rem; background-color: #4299e1; color: white; border-radius: 0.5rem; font-weight: bold; cursor: pointer; transition: background-color 0.3s; border: none;">Restart Game</button>
    </span>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreDisplay = document.getElementById('score');
            const messageBox = document.getElementById('message-box');
            const messageTitle = document.getElementById('message-title');
            const messageText = document.getElementById('message-text');
            const restartButton = document.getElementById('restartButton');

            let requestId;

            // Define game variables
            const GAME_WIDTH = 320;
            const GAME_HEIGHT = 480;

            // Player (Gem) properties
            const gem = {
                x: 50,
                y: 240,
                radius: 15,
                velocity: 0,
                gravity: 0.25,
                jumpPower: -5,
                color: '#63b3ed',
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.closePath();
                },
                update() {
                    this.velocity += this.gravity;
                    this.y += this.velocity;
                    // Keep the gem within the vertical bounds of the canvas
                    if (this.y + this.radius > GAME_HEIGHT) {
                        this.y = GAME_HEIGHT - this.radius;
                        this.velocity = 0;
                        gameState.isGameOver = true;
                    }
                    if (this.y - this.radius < 0) {
                        this.y = this.radius;
                        this.velocity = 0;
                        gameState.isGameOver = true;
                    }
                }
            };

            // Obstacle (Crystal) properties
            class Crystal {
                constructor(x, gapY, gapHeight, width, speed) {
                    this.x = x;
                    this.gapY = gapY;
                    this.gapHeight = gapHeight;
                    this.width = width;
                    this.speed = speed;
                    this.color = '#a0aec0';
                    this.isPassed = false;
                }
                draw() {
                    // Top crystal
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, 0, this.width, this.gapY);

                    // Bottom crystal
                    ctx.fillRect(this.x, this.gapY + this.gapHeight, this.width, GAME_HEIGHT - (this.gapY + this.gapHeight));
                }
                update() {
                    this.x -= this.speed; // Move left
                }
            }

            // Game state object
            const gameState = {
                score: 0,
                crystals: [],
                isGameOver: false,
                isGameStarted: false,
                crystalTimer: 0,
                // Initial game difficulty settings
                initialInterval: 120, // Frames
                baseSpeed: 2,
                reset() {
                    this.score = 0;
                    this.crystals = [];
                    this.isGameOver = false;
                    this.isGameStarted = false;
                    this.crystalTimer = 0;
                    gem.y = 240;
                    gem.velocity = 0;
                }
            };

            // Main game loop
            function gameLoop() {
                if (gameState.isGameOver) {
                    messageTitle.textContent = "Game Over!";
                    messageText.textContent = `You scored: ${gameState.score}! Click below to try again.`;
                    messageBox.style.display = 'block';
                    return;
                }

                // Update game state
                ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                if (gameState.isGameStarted) {
                    gem.update();

                    // Adjust difficulty based on score
                    const speedIncrease = Math.floor(gameState.score / 5) * 0.2; // Increase speed every 5 points
                    const currentSpeed = gameState.baseSpeed + speedIncrease;
                    
                    const intervalDecrease = Math.floor(gameState.score / 10) * 10; // Decrease interval every 10 points
                    const currentInterval = Math.max(60, gameState.initialInterval - intervalDecrease);

                    gameState.crystalTimer++;
                    if (gameState.crystalTimer >= currentInterval) {
                        const gapHeight = 100;
                        const gapY = Math.random() * (GAME_HEIGHT - gapHeight - 100) + 50;
                        gameState.crystals.push(new Crystal(GAME_WIDTH, gapY, gapHeight, 30, currentSpeed));
                        gameState.crystalTimer = 0;
                    }

                    gameState.crystals.forEach(crystal => {
                        crystal.update();
                        // Collision detection
                        if (
                            gem.x + gem.radius > crystal.x &&
                            gem.x - gem.radius < crystal.x + crystal.width
                        ) {
                            if (
                                gem.y - gem.radius < crystal.gapY ||
                                gem.y + gem.radius > crystal.gapY + crystal.gapHeight
                            ) {
                                gameState.isGameOver = true;
                            }
                        }

                        // Score update
                        if (
                            !crystal.isPassed &&
                            gem.x > crystal.x + crystal.width
                        ) {
                            crystal.isPassed = true;
                            gameState.score++;
                            scoreDisplay.textContent = gameState.score;
                        }
                    });

                    // Remove off-screen crystals
                    gameState.crystals = gameState.crystals.filter(crystal => crystal.x + crystal.width > 0);
                }

                // Draw everything
                gameState.crystals.forEach(crystal => crystal.draw());
                gem.draw();

                requestId = requestAnimationFrame(gameLoop);
            }

            // Event listeners for user input
            function handleInput() {
                if (!gameState.isGameStarted) {
                    gameState.isGameStarted = true;
                    messageBox.style.display = 'none';
                    gameLoop();
                }
                if (!gameState.isGameOver) {
                    gem.velocity = gem.jumpPower;
                }
            }

            function handleKeyDown(e) {
                if (e.code === 'Space' || e.code === 'ArrowUp') {
                    e.preventDefault();
                    handleInput();
                }
            }

            function handleRestart() {
                messageBox.style.display = 'none';
                gameState.reset();
                // Pass a new speed parameter to the crystals
                gameState.crystals = gameState.crystals.map(crystal => new Crystal(crystal.x, crystal.gapY, crystal.gapHeight, crystal.width, gameState.baseSpeed));
                gameLoop();
            }

            canvas.addEventListener('click', handleInput);
            document.addEventListener('keydown', handleKeyDown);
            restartButton.addEventListener('click', handleRestart);

            // Initial game state display
            function showStartMessage() {
                messageTitle.textContent = "Welcome to Flappy Gem";
                messageText.textContent = "Click or press Space to jump and start the game!";
                messageBox.style.display = 'block';
                scoreDisplay.textContent = "0";
            }
            
            showStartMessage();
        });
    </script>
</body>



<h1 align=center>t1a02-vibe-code-cleaning-fred.html</h1>

You need to put the cleaned code here. No CSS, no confusing divs and paragraphs. Just as simple as possible webpage html. <br><br>

If doing javascript script are the variables sensibly named using camelCase "myVar" etc don't use promises (.then) instead use async/await, no addEventListeners unless necessary, get chatGPT to make the changes. More changes... Only simple javascript nothing fancy.


<br><br>

Here is the original vibecode<br>
<iframe width="100%" height=400 src="vibe01.html"></iframe>


<br><br>

    Final: comments.

</html>
